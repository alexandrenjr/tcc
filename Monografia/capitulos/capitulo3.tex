\chapter{Algoritmo}

O algoritmo apresentado neste trabalho é um compilado de algoritmos desenvolvidos anteriormente, utilizando-se das aproximações cônica, elíptica e poligonal das regiões de $\mathscr{D}$-estabilidade do plano $z$. O objetivo deste trabalho é desenvolver em \emph{software} tais algoritmos e, ao informar parâmetros de projeto, determinar se é possível implementar um compensador que respeite os requisitos.

Para tal, o algoritmo pode ser divido em três partes, uma para cada aproximação, sendo a aproximação desejada escolhida via chamada da função. O \emph{software} utilizado foi o MATLAB, juntamente com o interpretador de LMIs YALMIP em conjunto com o solucionador númerico MOSEK.

Notação: $loc(v_1, v_2)$ determina o ponto que a reta que passa por $v_1$ e $v_2$. $ang(v_1, v_2)$ cruza o eixo real. $ang(v_1, v_2)$ refere-se ao ângulo entre aquela reta e o eixo real. 

\section{Aproximação cônica}
Para o mapeamento cônico das curvas $\zeta$-constante e $\omega_n$-constante, são utilizados os setores cônicos determinados via \eqref{eq:LMIESetorConicoDireito} e \eqref{eq:LMIESetorConicoEsquerdo}, e retas verticais como apresentado em \ref{eq:LMIRightBounded}.

Para a primeira curva, a ideia consiste em utilizar os pontos extremos calculados na seção \ref{sec:DEstabilidadeZ}, onde serão os centros dos setores cônicos. Os ângulos, medidos no sentido anti-horário, são determinados a partir de um terceiro ponto, conforme a figura \ref{subfig:AproximacaoConicaZeta}. A escolha do ponto $v$ é feita de maneira que a área do triângulo $\widehat{v_ov_iv}$ seja a maior possível. Um algoritmo linear foi usado para encontrar este ponto.

\begin{figure}[!hb]
  \centering
  \begin{subfigure}[t]{0.4\columnwidth}
      \input{figuras/aproximacao_conica_zeta.tikz}
      \caption{}
      \label{subfig:AproximacaoConicaZeta}
  \end{subfigure}
  \begin{subfigure}[t]{0.4\columnwidth}
      \input{figuras/aproximacao_conica_wn.tikz}
      \caption{}
      \label{subfig:AproximacaoConicaWn}
  \end{subfigure}
  \caption{}
  \label{fig:AproximacoesConica}
\end{figure}

\begin{algorithm}[ht!]
  \caption{Aproximação cônica da taxa de amortecimento}\label{alg:AproximacaoConicaZeta}
  \begin{algorithmic}[1]
    \Require $\sigma$, $\zeta$, $T_s$
    \Ensure $K$
    \State $Z_o \gets $ $z(\zeta,\omega_{nmin})$
    \State $Z_i \gets $ $z\left(\zeta,\omega_{nmax}\right)$
    \State $Z \gets z(\zeta,\omega_n)$, onde a área do triângulo formado é a maior possível
    \State $F \gets P \succ 0$
    \State $F \gets F \cap \eqref{eq:LMIEstabilidadeRelativa}$ com $r = \exp{\left(-|\sigma|T_s\right)}$ \Comment{Taxa de amortecimento}
    \State $F \gets F \cap \eqref{eq:LMIESetorConicoEsquerdo}$ com $\alpha = Z_o$ e $\theta = ang(Z,Z_i)$ \Comment{Setor cônico esquerdo}
    \State $F \gets F \cap \eqref{eq:LMIESetorConicoDireito}$ com $\alpha = Z_i$ e $\theta = ang(Z,Z_o)$ \Comment{Setor cônico direito}
    \State $F \gets F \cap \eqref{eq:LMIRightBounded}$ com $\alpha = Z_i$  \Comment{Reta vertical}
    \State Verificar se o problema é factível
    \State $K \gets ZP^{-1}$
  \end{algorithmic}
\end{algorithm}

Com tais informações determinadas, é possível aplicar o algoritmo \ref{alg:AproximacaoConicaZeta}. Um setor cônico voltado para a direita, com centro em $Z_i$ e ângulo $\theta_1$, e outro voltado para a esquerda, com centro em $Z_o$ e ângulo $\theta_2$, são aplicados. Além disso, para limitar a simetria do setor cônico com centro em $Z_i$, uma reta que passa por este ponto é aplicada.

A região de $\mathscr{D}$-estabilidade resultante é a intersecção de tais regiões. Ao ser unida com a restrição da taxa de decaimento, o setor cônico com centro em $Z_o$ é limitado por esta região. Após resolvido o problema, o algoritmo determina a factibilidade da solução encontrada e retorna a matrix $K$ de estabiliza o sistema com os parâmetros de projeto informados.

Em relação à largura de banda, a mesma ideia é aplicada \cite{CHIQUETO2021}. Contudo, neste caso, somente um setor cônico com centro em $N_i$ limitado pela direita por uma reta que passa neste ponto são usados. Os pontos $N_o$ e $N_i$ são determinados via \eqref{eq:PontoMinimoExtremoWnZ} e \eqref{eq:PontoMaximoExtremoWnZ}, respectivamente. Além disso, o ângulo $\theta$ é determinado através de $ang(N_o,N_i)$.  

\begin{algorithm}[hb!]
  \caption{Aproximação cônica da curva $N_y$}\label{alg:AproximacaoConicaNy}
  \begin{algorithmic}[1]
    \Require $\sigma$, $\omega_n$
    \Ensure $K$
    \State $N_o \gets $ $z(\zeta_{min},\omega_n)$
    \State $N_i \gets $ $z(\zeta_{max},\omega_n)$
    \State $F \gets P \succ 0$
    \State $F \gets F \cap \eqref{eq:LMIEstabilidadeRelativa}$ com $r = \exp{\left(-|\sigma|T_s\right)}$ \Comment{Taxa de amortecimento}
    \State $F \gets F \cap \eqref{eq:LMIESetorConicoDireito}$ com $\alpha = N_i$ e $\theta = ang(N_i,N_o)$ \Comment{Setor cônico direito}
    \State $F \gets F \cap \eqref{eq:LMIRightBounded}$ com $\alpha = N_i$ \Comment{Reta vertical}
    \State Verificar se o problema é factível
    \State $K \gets ZP^{-1}$
  \end{algorithmic}
\end{algorithm}

Com tais informações determinadas, é possível utilizar o algoritmo \ref{alg:AproximacaoConicaNy}. Um detalhe que é facilmente observado é a rápida perda de convexidade da curva $N_y$. Logo, caso a constante $N_y$ seja menor que $4.86$ \cite{CHIQUETO2021}, o algoritmo retorna um alerta devido a falta de convexidade. Assim, para fins práticos, a pouca e a falta convexidade de tais curvas não foram tratadas.

\section{Aproximação elíptica}
Para a aproximação elíptica, apenas a região $\omega_n$-constante foi aproximada. A ideia consiste em encontrar a maior elipse inscrita, a fim de aproveitar melhor área. Para tal, é preciso verificar se o valor escolhido para $\omega_n$ e $T_s$ resultem em uma área convexa \cite{CHIQUETO2021}. Caso os parâmetros informados atendam à restricções, o algoritmo

\begin{figure}[!ht]
  \centering
  \input{figuras/aproximacao_eliptica_wn.tikz}
  \caption{}
  \label{fig:AproximacaoEliptica}
\end{figure}

\begin{algorithm}[hb!]
  \caption{Aproximação elíptica da curva $N_y$}\label{alg:AproximacaoElipticaNy}
  \begin{algorithmic}[1]
    \Require $\sigma$, $T_s$, $N_y$
    \Ensure $K$
    \State $F \gets P \succ 0$
    \State $F \gets F \cap \eqref{eq:LMIEstabilidadeRelativa}$, com $r = \exp{\left(-|\sigma|T_s\right)}$ \Comment{Taxa de amortecimento}
    \State $F \gets \eqref{eq:LMIElipse}$, com $a = \eqref{eq:PontoAElipse}$ e $b = \eqref{eq:PontoBElipse}$
    \State Verificar se o problema é factível
    \State $K \gets ZP^{-1}$
  \end{algorithmic}
\end{algorithm}

\section{Aproximação poligonal}
A aproximação poligonal consiste na ideia de aproximar as regiões de interesse em um polígono com o maior número de lados possíveis. Para isto, o algoritmo irá partir de uma aproximação cônica simples. A partir daí, entre os dois pontos usados para definir o setor, um ponto intermediário é calculado e dois novos setores cônicos são definidos.
Sob a ótica do número de lados, a cada iteração, um novo lado é acrescentado e, consequentemente, a área é incrementada. Em um número grande de iterações, a região aproximada tende a área total.

Para a região $\zeta$-constante, um setor cônico voltado para esquerda e centro em $Z_o$ é usado como aproximação inicial \cite{WISNIEWSKI2019}. Contudo, devido à cúspide daquela, uma reta em $Z_i$ é usada para eliminar tal convexidade. Dito isso, surge a necessidade de calcular o ponto $\bar{z_i}$, localizado entre os pontos máximo e mínimo, onde possui a mesma parte real que $Z_i$, conforme a figura:

\begin{algorithm}[ht!]
  \caption{Aproximação poligonal da região $\zeta$-constante}\label{alg:AproximacaoPoligonalZeta}
  \begin{algorithmic}[1]
    \Require $\sigma$, $\zeta$, $T_s$
    \Ensure $K$
    \State $l \gets 0$
    \State $V_o \gets z(\zeta,\omega_{nmin},T_s)$
    \State $V_i \gets z(\zeta,\omega_{nmax},T_s)$
    \State $V \gets z(\zeta,\omega_n,T_s)$, tal que $\Re{(V)} = V_i$
    \State $pontos1 \gets$ [$0$ $\omega_{ne}$]
    \State $pontos2 \gets pontos1$
    \State $vec1 \gets$ [$V_o$ $V$]
    \State $vec2 \gets vec1$
    \State $F \gets P \succ 0$
    \State $F \gets \eqref{eq:LMIEstabilidadeRelativa}$ com $r = \exp{\left(-|\sigma|T_s\right)}$ \Comment{Taxa de amortecimento}
    \State $F \gets F \cap \eqref{eq:LMIESetorConicoEsquerdo}$, com $\alpha = V_o$ e $\theta = ang(V_o,V)$ \Comment{Voltado para a esquerda}
    \State $F \gets F \cap \eqref{eq:LMIRightBounded}$, com $\alpha = V_i$ \Comment{Reta vertical}
    \State Verificar se o problema é factível
    \While{Problema for infactível}
      \If{$l < $ número de elementos em $vec1 - 1$}
        \State $l \gets l + 1$
      \Else
        \State $l \gets 1$
        \State $vec1 \gets vec2$
        \State $pontos1 \gets pontos2$
      \EndIf
        \State $F \gets$ \O \Comment{Descarta as restrições anteriores}
        \State $F \gets P \succ 0$
        \State $F \gets \eqref{eq:LMIEstabilidadeRelativa}$ com $r = \exp{\left(-|\sigma|T_s\right)}$ \Comment{Taxa de amortecimento}
        \State $ponto_{new1} \gets (pontos1(l)+pontos1(l+1))/2$
        \State $V_{new1} \gets z(\zeta, ponto_{new1}, T_s)$
        \State $pontos2 \gets$ [$pontos2$ $ponto_{new1}$]
        \State Orderna de forma decrescente $pontos2$
        \State $vec2 \gets$ [$vec2$ $V_{new1}$]
        \State Orderna de forma decrescente $vec2$
        \State $F \gets F \cap \eqref{eq:LMIRightBounded}$, com $\alpha = V_i$ \Comment{Reta vertical}
        \For{$m = 1$ até número de elementos de $vec1-1$}
          \State $u \gets loc(vec2(m),vec2(m+1))$
          \If{$u < 0$}
            \State $F\gets F \cap \eqref{eq:LMIESetorConicoDireito}$, com $\alpha = u$ e $\theta = ang(vec2(m+1),u)$ \Comment{Voltado para a direita}
          \Else
            \State $F\gets F \cap \eqref{eq:LMIESetorConicoEsquerdo}$, com $\alpha = u$ e $\theta = ang(vec2(m+1),u)$ \Comment{Voltado para a esquerda}
          \EndIf
        \EndFor
        \State Verificar se o problema é factível 
    \EndWhile
    \State $K \gets ZP^{-1}$
  \end{algorithmic}
\end{algorithm} 

\begin{algorithm}[ht!]
  \caption{Aproximação poligonal da região $\omega_n$-constante}\label{alg:AproximacaoPoligonalWn}
  \begin{algorithmic}[1]
    \Require $\sigma$, $\omega_n$, $T_s$
    \Ensure $K$
    \State $l \gets 0$
    \State $N_o \gets z(\zeta_{min},\omega_n,T_s)$
    \State $N_i \gets z(\zeta_{max},\omega_n,T_s)$
    \State $pontos3 \gets$ [$0$ $1$]
    \State $pontos4 \gets pontos3$
    \State $vec3 \gets$ [$N_i$ $N_o$]
    \State $vec4 \gets vec3$
    \State $F \gets P \succ 0$
    \State $F \gets \eqref{eq:LMIEstabilidadeRelativa}$ com $r = \exp{\left(-|\sigma|T_s\right)}$ \Comment{Taxa de amortecimento}
    \State $F \gets F \cap \eqref{eq:LMIESetorConicoDireito}$, com $\alpha = N_i$ e $\theta = ang(N_o,N_i)$ \Comment{Voltado para a direita}
    \State $F \gets F \cap \eqref{eq:LMIRightBounded}$, com $\alpha = N_i$ \Comment{Reta vertical}
    \State Verificar se o problema é factível
    \While{Problema for infactível}
      \If{$l < $ número de elementos em $vec3 - 1$}
        \State $l \gets l + 1$
      \Else
        \State $l \gets 1$
        \State $vec3 \gets vec4$
        \State $pontos1 \gets pontos2$
      \EndIf
        \State $F \gets$ \O \Comment{Descarta as restrições anteriores}
        \State $F \gets P \succ 0$
        \State $F \gets \eqref{eq:LMIEstabilidadeRelativa}$ com $r = \exp{\left(-|\sigma|T_s\right)}$ \Comment{Taxa de amortecimento}
        \State $ponto_{new} \gets (pontos3(l)+pontos3(l+1))/2$
        \State $V_{new2} \gets z(ponto_{new2}, \omega_n, T_s)$
        \State $pontos4 \gets$ [$pontos4$ $ponto_{new2}$]
        \State Orderna de forma decrescente $pontos4$
        \State $vec4 \gets$ [$vec4$ $V_{new2}$]
        \State Orderna de forma decrescente $vec4$
        \State $F \gets F \cap \eqref{eq:LMIRightBounded}$, com $\alpha = V_i$ \Comment{Reta vertical}
        \For{$m = 1$ até número de elementos de $vec3-1$}
          \State $u_2 \gets loc(vec4(m),vec4(m+1))$
          \State $F \gets F \cap \eqref{eq:LMIESetorConicoDireito}$, com $\alpha = u_2$ e $\theta = ang(vec4(m),u_2)$
        \EndFor
        \State Verificar se o problema é factível
    \EndWhile
    \State $K \gets ZP^{-1}$
  \end{algorithmic}
\end{algorithm}

Para tal, utiliza-se o cálculo númerico para encontrar uma solução aproximada. Com tal ponto calculado e a não convexidade da cúspide tratada, é possível utilizar o algoritmo \ref{alg:AproximacaoPoligonalZeta}. Os vértices iniciais $z_o$ e $z_i$ do ramo são guardados em um vetor. Em paralelo a isso, os valores de $\omega_n$ que geram tais valores em $\eqref{eq:FuncaoPontoZ}$ também são armazenados. A ideia do algoritmo é, a cada iteração, calcular o ponto médio entre dois pontos consecutivos.

Contudo, antes do algoritmo voltar para o início dos vetores mencionados, é preciso que ele calcule o ponto médio entre todos os pontos do vetor atual. Para isso, cópias dos vetores de vértices e de pontos foram inicializados, a fim de controlarem tal fluxo. Assim, quando o algoritmo terminar de percorrer o "vetor anterior", tal conjunto é atualizado com os novos pontos e vértices calculados ao final deste processo.

Em relação ao cálculos dos pontos intermediários, a inclinação destes juntamente com o ponto anterior podem ser positiva ou negativa. O uso da função $loc$ se torna enssencial, pois caso o ponto resultante for menor que zero, a reta que passa pelos pontos possui inclinação positiva e negativa, caso contrário \cite{WISNIEWSKI2019}. Assim, os setores cônicos gerados seguem a orientação de tal reta, com centro naquele ponto calculado.

Para a região $\omega_n$-constante, a ideia é similar. A aproxmição inicial emprega-se de apenas um setor cônico voltado para a direita com centro em $n_i = z(\zeta_{max},\omega_n,T_s)$, com $\zeta_{max} = 1$. O ângulo $\theta$ em \eqref{eq:LMIESetorConicoDireito} é definido a partir do ângulo entre a reta $\overline{n_on_i}$ e o eixo real, onde $n_o = z(\zeta_{min},\omega_n,T_s)$, com $\zeta_{min} = 0$.

Caso esta região não for factível, basta calcular o ponto intermediário entre $n_o$ e $n_i$ e definir dois novos setores cônicos, a fim de aumentar a área. Novamente, para o novo ponto calculado e o anteriormente, usa-se da função $loc$ para determinar ponto que a reta que passsa por aqueles pontos cruza e eixo real, onde será o centro do novo setor cônico. Já o ângulo seguirá o mesmo critério, sendo o valor entre aquela reta e o eixo real.

Assim, a cada iteração, o algoritmo adiciona dois novos setores cônicos e os intersecta com as regiões previamente definidos. Ao final de uma iteração, o algoritmo descarta tais regiões e começa a aumentar a área de $\mathscr{D}$-estabilidade a partir de $n_i$ até $n_o$.

\begin{figure}[!hb]
  \centering
  \begin{subfigure}[t]{0.2\columnwidth}
      \input{figuras/aproximacao_poligonal_l1.tikz}
      \caption{}
      \label{subfig:AproximacaoPoligonalWn1}
  \end{subfigure}
  \begin{subfigure}[t]{0.2\columnwidth}
      \input{figuras/aproximacao_poligonal_l2.tikz}
      \caption{}
      \label{subfig:AproximacaoPoligonalWn2}
  \end{subfigure}
  \begin{subfigure}[t]{0.2\columnwidth}
    \input{figuras/aproximacao_poligonal_l3.tikz}
    \caption{}
    \label{subfig:AproximacaoPoligonalWn3}
  \end{subfigure}
  \begin{subfigure}[t]{0.2\columnwidth}
    \input{figuras/aproximacao_poligonal_l4.tikz}
    \caption{}
    \label{subfig:AproximacaoPoligonalWn4}
  \end{subfigure}
  \caption{}
  \label{fig:AproximacoesPoligonalWn}
\end{figure}